{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GNE Solver","text":"<p>A Python library to compute Generalized Nash Equilibria.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>  pip install gne-solver\n</code></pre>"},{"location":"#custom-types","title":"Custom Types","text":""},{"location":"examples/","title":"Examples","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#flatten-variables","title":"Flatten Variables","text":"<p>Flatten a collection of vectors and scalars into a single list.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>VectorList</code> <p>List of 2D NumPy arrays with shape (n, 1), representing column vectors of floats.</p> required <code>scalars</code> <code>List[float]</code> <p>A list of scalar values to append after the flattened vectors.</p> required <p>Returns:</p> Type Description <code>list of floats</code> <p>Single list containing all elements from the input vectors, followed by the scalar values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; vectors = [np.array([[1.0], [2.0]]), np.array([[3.0]])]\n&gt;&gt;&gt; scalars = [4.0, 5.0]\n&gt;&gt;&gt; flatten_variables(vectors, scalars)\n&gt;&gt;&gt; [1.0, 2.0, 3.0, 4.0, 5.0]\n</code></pre>"},{"location":"reference/#create-wrapped-function","title":"Create Wrapped Function","text":"<p>Create a wrapped objective function for a single player's optimization.</p> <p>Fix all players' action vectors except the one at <code>player_idx</code>, and return a new function that accepts only this player's decision variables as input. The wrapped function automatically reconstructs the full list of action vectors and evaluates the original objective function.</p> <p>Parameters:</p> Name Type Description Default <code>original_func</code> <code>ObjFunction</code> <p>The original objective function that accepts a list of action vectors.</p> required <code>actions</code> <code>VectorList</code> <p>List of 2D NumPy arrays with shape (n, 1), representing all players' current actions.</p> required <code>player_idx</code> <code>int</code> <p>Index of the player whose action vector should remain variable in the wrapped function.</p> required <p>Returns:</p> Type Description <code>WrappedFunction</code> <p>A function that takes the chosen player's action vector (as a list of floats), reshapes it into a 2D column vector with shape (n, 1), and evaluates <code>original_func</code> with the updated set of actions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; def original_func(var_list):\n...     return sum(v.sum() for v in var_list)\n&gt;&gt;&gt; actions = [np.array([[1.0], [2.0]]), np.array([[3.0]])]\n&gt;&gt;&gt; wrapped = create_wrapped_function(original_func, actions, player_idx=0)\n&gt;&gt;&gt; wrapped([10.0, 20.0])\n33.0\n</code></pre>"},{"location":"reference/#create-wrapped-function-single","title":"Create Wrapped Function Single","text":"<p>Create a wrapped function returning only a single player's output.</p> <p>Fix all players' action vectors except the one at <code>player_idx</code>, and return a new function that accepts only this player's decision variables as input. The wrapped function reconstructs the full list of action vectors, evaluates the original function, and returns only the output corresponding to the chosen player.</p> <p>Parameters:</p> Name Type Description Default <code>original_func</code> <code>ObjFunction</code> <p>The original objective function that accepts a list of action vectors.</p> required <code>actions</code> <code>VectorList</code> <p>List of 2D NumPy arrays with shape (n, 1), representing all players' current actions.</p> required <code>player_idx</code> <code>int</code> <p>Index of the player whose output should be returned by the wrapped function.</p> required <p>Returns:</p> Type Description <code>WrappedFunction</code> <p>A function that takes the chosen player's action vector, reshapes it into a 2D column vector with shape (n, 1), evaluates <code>original_func</code> with the updated set of actions, and returns only the output for that player.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; def original_func(var_list):\n...     return [v.sum() for v in var_list]\n&gt;&gt;&gt; actions = [np.array([[1.0], [2.0]]), np.array([[3.0]])]\n&gt;&gt;&gt; wrapped_single = create_wrapped_function_single(original_func, actions, player_idx=0)\n&gt;&gt;&gt; wrapped_single([10.0, 20.0])\n30.0\n</code></pre>"},{"location":"reference/#one-hot-encoding","title":"One Hot Encoding","text":"<p>This function builds a matrix mapping each player\u2019s action variables to the functions they are assigned  Creates a zeros NumPy matrix and then iterates through functions mapping them to correct player's action variables</p> <p>and assigning them to the matrix.</p> <p>Parameters:</p> Name Type Description Default <code>funcs_idx</code> <code>List</code> <p>A list of either integers or PlayerConstraint (PlayerConstraint=Union[int], None, list[None])</p> required <code>sizes</code> <code>List[int]</code> <p>A list of integers thats length needs to equal the length of funcs_idx</p> required <code>num_functions</code> <code>int</code> required <code>An</code> required <p>Returns:</p> Type Description <code>Matrix</code> <p>Returns a matrix of shape (sum(sizes), num_functions), where each row represents a player's variables and each column represents a function.</p> <p>Examples:</p> <p>''  &gt;&gt;&gt; funcs_idx = [[0,2], None, [1] ''  &gt;&gt;&gt; sizes = [2,3,1]</p> <p>num_functions = 3 M = one_hot_encoding(funcs_idx, sizes, num_functions) 3.14</p>"},{"location":"reference/#construct-vectors","title":"Construct Vectors","text":"<p>Split a concatenated action array into separate action vectors for each player.</p> <p>This function validates the input types and shapes, ensuring that the total number of rows in \"actions\" matches the sum of \"action_sizes\". It then splits the stacked column vector into per-player subarrays in the same order as specified in \"action_sizes\".</p> <p>Parameters:</p> Name Type Description Default <code>actions</code> <code>numpy.ndarray of shape (sum(action_sizes), 1)</code> <p>A 2D NumPy array containing all players' actions stacked vertically. The number of rows must equal the sum of all entries in <code>action_sizes</code>.</p> required <code>action_sizes</code> <code>list of int</code> <p>A list specifying the length of each player's action vector. The sum of these sizes must match the number of rows in <code>actions</code>.</p> required <p>Raises:</p> Type Description <code>Type Error</code> <p>if \"actions\" is not a NumPy array or if \"action_sizes\" is not a list of integers</p> <code>Value Error</code> <p>If the number of rows in \"actions\" does not equal the sum of all entries in <code>action_sizes</code>.</p> <p>Returns:</p> Type Description <code>list of numpy.ndarray</code> <p>A list of 2D NumPy arrays, each corresponding to one player's action vector. The arrays are in the same order as the players in <code>action_sizes</code>.</p> <p>Examples:</p> <p>actions = np.array([[1.0], [2.0], [3.0], [4.0]]) action_sizes = [2, 2] construct_vectors(actions, action_sizes) [array([[1.],         [2.]]),  array([[3.],         [4.]])]</p>"},{"location":"user_guide/","title":"User Guide","text":""},{"location":"development/overview/","title":"Development","text":"<p>Example of documentation using same theme FastAPI</p> <p>Theme documentation: Material for MkDocs</p> <p>For full documentation visit mkdocs.org.</p>"},{"location":"development/overview/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve --livereload</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"development/overview/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"development/standards/","title":"\ud83d\udcd6 Docstring Guidelines (NumPy Style)","text":"<p>This document defines the standard docstring format to be used across the project. We follow the NumPy style conventions, as supported by mkdocstrings and rendered by Material for MkDocs.</p>"},{"location":"development/standards/#1-general-principles","title":"1. General Principles","text":"<ul> <li>Every public function, class, method, and module must have a docstring.  </li> <li>Use NumPy style sections (<code>Parameters</code>, <code>Returns</code>, <code>Raises</code>, <code>Examples</code>, etc.).  </li> <li>Start with a short, one-line summary in imperative mood (e.g., \"Compute equilibrium strategies\", not \"This function computes...\").  </li> <li>Follow with an extended description if necessary.  </li> <li>Keep line length reasonable (~79\u2013100 chars).  </li> <li>Private functions (starting with <code>_</code>) may have shorter docstrings, but should still explain purpose if non-trivial.  </li> </ul>"},{"location":"development/standards/#2-function-method-docstrings","title":"2. Function &amp; Method Docstrings","text":""},{"location":"development/standards/#template","title":"Template","text":"<pre><code>def function_name(param1: int, param2: str = \"default\") -&gt; float:\n    \"\"\"\n    One-line summary of the function.\n\n    Extended description if necessary. Can span multiple sentences to\n    explain the context, usage, or algorithm.\n\n    Parameters\n    ----------\n    param1 : int\n        Description of the parameter. Include units if applicable.\n    param2 : str, optional\n        Description of the parameter. State the default if not obvious\n        from the signature.\n\n    Returns\n    -------\n    float\n        Description of the return value.\n\n    Raises\n    ------\n    ValueError\n        Explanation of the condition that causes this exception.\n\n    Examples\n    --------\n    &gt;&gt;&gt; result = function_name(5, \"option\")\n    &gt;&gt;&gt; print(result)\n    3.14\n    \"\"\"\n</code></pre>"},{"location":"development/standards/#3-function-method-docstrings","title":"3. Function &amp; Method Docstrings","text":""},{"location":"development/standards/#template_1","title":"Template","text":"<pre><code>class Solver:\n    \"\"\"\n    Generalized Nash Equilibrium solver.\n\n    Provides algorithms to compute equilibria in generalized Nash games.\n\n    Parameters\n    ----------\n    tol : float, optional\n        Convergence tolerance. Default is ``1e-6``.\n    max_iter : int, optional\n        Maximum number of iterations. Default is ``1000``.\n\n    Attributes\n    ----------\n    tol : float\n        Convergence tolerance.\n    max_iter : int\n        Maximum number of iterations.\n\n    See Also\n    --------\n    create_game : Utility to create game instances.\n    flatten_variables : Function used internally to reshape variables.\n    \"\"\"\n\n</code></pre>"},{"location":"development/standards/#module-docstrings","title":"Module Docstrings","text":"<p>At the top of every Python file:</p> <pre><code>\"\"\"\nUtilities for game creation.\n\nThis module provides helper functions to build and initialize\ngeneralized Nash equilibrium problems.\n\"\"\"\n\n</code></pre>"},{"location":"development/standards/#sections-to-use","title":"Sections to Use","text":"Section When to Use Notes Parameters Always Document type, shape, and description. Returns If function returns something Be explicit about types and shapes. Raises If function can raise exceptions Name the exception and explain why. Attributes For classes List important public attributes. See Also Optional Cross-reference related functions/classes. Examples Strongly encouraged Use <code>&gt;&gt;&gt;</code> doctest style. Keep minimal but runnable."},{"location":"development/standards/#examples-style","title":"Examples Style","text":"<ul> <li>Always use &gt;&gt;&gt; prompt.</li> <li>Show inputs and outputs.</li> <li>Keep examples small, self-contained, and copy-pasteable.</li> <li>Example blocks must be valid Python so they can be tested via pytest --doctest-modules.</li> </ul>"},{"location":"development/standards/#good-example","title":"Good Example:","text":"<pre><code>Examples\n--------\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; vectors = [np.array([[1.0], [2.0]]), np.array([[3.0]])]\n&gt;&gt;&gt; scalars = [4.0, 5.0]\n&gt;&gt;&gt; flatten_variables(vectors, scalars)\n[1.0, 2.0, 3.0, 4.0, 5.0]\n\n</code></pre>"},{"location":"development/standards/#dos-and-donts","title":"Do's and Don'ts","text":"<p>\u2705 Do:</p> <ul> <li>Use backticks for code (e.g., \"matrix\").</li> <li>Be explicit with shapes (array of shape (n, m)).</li> <li>Keep summaries short and imperative.</li> </ul> <p>\u274c Don\u2019t:</p> <ul> <li>Repeat type hints unnecessarily: \"param1 : int, an integer\" is redundant.</li> <li>Write personal notes or informal language.</li> <li>Omit examples for important public functions.</li> </ul>"}]}